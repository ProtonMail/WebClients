import type { LexicalNode } from 'lexical'
import {
  $createRangeSelection,
  $getNodeByKey,
  $getSelection,
  $isElementNode,
  $isRangeSelection,
  $isTextNode,
} from 'lexical'
import { GenerateUUID } from '@proton/docs-core'
import { $createSuggestionNode, $isSuggestionNode } from './ProtonNode'
import { $wrapSelectionInSuggestionNode, $isNodeNotInline } from './Utils'
import type { Logger } from '@proton/utils/logs'

/**
 * This command is triggered by $insertDataTransferForRichText to allow
 * overriding the insertion behavior of nodes generated by it from a
 * DataTransfer, usually from a paste-related event.
 *
 * If there is an existing non-collapsed selection, we first wrap that
 * with "delete" suggestion node(s). Then, if the nodes to insert are
 * all inline, then we append them to a single suggestion node and insert
 * that.
 *
 * If the nodes are not all inline, then we let Lexical first insert those
 * nodes using RangeSelection.insertNodes(), build a selection by using the
 * selection of the selection before any insertion as the anchor
 * and the anchor of the selection after insertion as the focus, and then
 * we wrap that selection with "insert" suggestion node(s).
 */
export function $selectionInsertClipboardNodes(
  nodes: LexicalNode[],
  onSuggestionCreation: (id: string) => void,
  logger: Logger,
): boolean {
  logger.info('Inserting nodes at current selection', nodes)

  const selection = $getSelection()
  if (!$isRangeSelection(selection)) {
    logger.info('Current selection is not range selection')
    return true
  }

  const isInitialSelectionBackward = selection.isBackward()

  logger.info('Is selection backward?', isInitialSelectionBackward, selection.anchor.offset, selection.focus.offset)

  const point = selection.focus
  const anchorBeforeInserting = {
    key: point.key,
    offset: point.offset,
    type: point.type,
  }
  const pointNode = point.getNode()
  const currentBlock = pointNode.getTopLevelElement()
  const isAtStartOfBlock =
    $isElementNode(currentBlock) &&
    anchorBeforeInserting.offset === 0 &&
    currentBlock.getFirstDescendant()?.is(pointNode)

  const suggestionID = GenerateUUID()

  const isInitialSelectionNotCollapsed = !selection.isCollapsed()
  if (isInitialSelectionNotCollapsed) {
    $wrapSelectionInSuggestionNode(selection, selection.isBackward(), suggestionID, 'delete', logger)
    onSuggestionCreation(suggestionID)
    logger.info('Wrapped non-collapsed selection as delete suggestion', suggestionID)
  }

  const latestSelection = $getSelection()
  if (!$isRangeSelection(latestSelection) || !latestSelection.isCollapsed()) {
    logger.info('Latest selection is not range selection or is not collapsed')
    return true
  }

  if (isInitialSelectionNotCollapsed && !isInitialSelectionBackward) {
    const point = latestSelection.focus
    anchorBeforeInserting.key = point.key
    anchorBeforeInserting.offset = point.offset
    anchorBeforeInserting.type = point.type
  }

  const allNodesAreInline = !nodes.some($isNodeNotInline)
  if (allNodesAreInline) {
    const suggestionNode = $createSuggestionNode(suggestionID, 'insert')
    suggestionNode.append(...nodes)
    latestSelection.insertNodes([suggestionNode])
    logger.info('Appended all nodes as one suggestion node as all nodes were inline')
    const prevSibling = suggestionNode.getPreviousSibling()
    const nextSibling = suggestionNode.getNextSibling()
    const sibling = $isSuggestionNode(prevSibling) ? prevSibling : nextSibling
    if ($isSuggestionNode(sibling) && sibling.getSuggestionTypeOrThrow() === 'delete') {
      logger.info('Using same suggestion ID as sibling to create replace suggestion')
      suggestionNode.setSuggestionId(sibling.getSuggestionIdOrThrow())
    } else {
      onSuggestionCreation(suggestionID)
    }
    return true
  }

  const selectionBeforeInserting = latestSelection

  logger.info('Anchor before inserting:', anchorBeforeInserting)

  logger.info('Inserting nodes into latest selection')
  selectionBeforeInserting.insertNodes(nodes)

  const selectionAfterInserting = $getSelection()
  if (!$isRangeSelection(selectionAfterInserting) || !selectionAfterInserting.isCollapsed()) {
    throw new Error('Cannot ensure inserted nodes are marked as suggestion')
  }

  const anchorAfterInserting = selectionAfterInserting.anchor

  logger.info('Anchor after inserting:', anchorAfterInserting)

  const doesBeforeAnchorExist = $getNodeByKey(anchorBeforeInserting.key)?.isAttached()

  const selectionToMark = $createRangeSelection()
  if (isAtStartOfBlock || !doesBeforeAnchorExist) {
    // When inserting at the start of a block or into an empty paragraph,
    // Lexical creates a new paragraph, moves the contents of the current block
    // into it and after inserting all the nodes removes the initial block,
    // so we need to use the first inserted node as the new anchor.
    logger.info('Anchor before insertion doesnt exist, using first inserted node')
    const firstNode = nodes[0]
    selectionToMark.anchor.set(firstNode.getKey(), 0, $isTextNode(firstNode) ? 'text' : 'element')
  } else {
    logger.info('Anchor before insertion still exists, using that.')
    selectionToMark.anchor.set(anchorBeforeInserting.key, anchorBeforeInserting.offset, anchorBeforeInserting.type)
  }
  selectionToMark.focus.set(anchorAfterInserting.key, anchorAfterInserting.offset, anchorAfterInserting.type)
  logger.info('Selection to wrap:', selectionToMark)

  const suggestionNodes = $wrapSelectionInSuggestionNode(
    selectionToMark,
    selectionToMark.isBackward(),
    suggestionID,
    'insert',
    logger,
  )
  if (!suggestionNodes.length) {
    logger.info('Selection was not wrapped')
    return true
  }

  const firstNode = suggestionNodes[0]
  const firstNodePrevSibling = firstNode.getPreviousSibling()

  const lastNode = suggestionNodes[suggestionNodes.length - 1]
  const lastNodeNextSibling = lastNode.getNextSibling()

  let suggestionIDtoUseForReplace: string | undefined
  if ($isSuggestionNode(firstNodePrevSibling) && firstNodePrevSibling.getSuggestionTypeOrThrow() === 'delete') {
    suggestionIDtoUseForReplace = firstNodePrevSibling.getSuggestionIdOrThrow()
  } else if ($isSuggestionNode(lastNodeNextSibling) && lastNodeNextSibling.getSuggestionTypeOrThrow() === 'delete') {
    suggestionIDtoUseForReplace = lastNodeNextSibling.getSuggestionIdOrThrow()
  }

  if (suggestionIDtoUseForReplace) {
    logger.info('Creating replace suggestion by using same suggestion ID as delete suggestion sibling')
    for (const suggestion of suggestionNodes) {
      suggestion.setSuggestionId(suggestionIDtoUseForReplace)
    }
  } else {
    logger.info('Wrapped selection in suggestion', suggestionID)
    onSuggestionCreation(suggestionID)
  }

  return true
}
