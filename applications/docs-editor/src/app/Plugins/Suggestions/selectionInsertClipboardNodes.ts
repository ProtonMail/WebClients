import type { LexicalNode } from 'lexical'
import { $createRangeSelection, $getNodeByKey, $getSelection, $isElementNode, $isRangeSelection } from 'lexical'
import { GenerateUUID } from '@proton/docs-core'
import { $createSuggestionNode } from './ProtonNode'
import { $wrapSelectionInSuggestionNode, $isNodeNotInline } from './Utils'
import type { Logger } from '@proton/utils/logs'

/**
 * This command is triggered by $insertDataTransferForRichText to allow
 * overriding the insertion behavior of nodes generated by it from a
 * DataTransfer, usually from a paste-related event.
 *
 * If there is an existing non-collapsed selection, we first wrap that
 * with "delete" suggestion node(s). Then, if the nodes to insert are
 * all inline, then we append them to a single suggestion node and insert
 * that.
 *
 * If the nodes are not all inline, then we let Lexical first insert those
 * nodes using RangeSelection.insertNodes(), build a selection by using the
 * selection of the selection before any insertion as the anchor
 * and the anchor of the selection after insertion as the focus, and then
 * we wrap that selection with "insert" suggestion node(s).
 */
export function $selectionInsertClipboardNodes(
  nodes: LexicalNode[],
  onSuggestionCreation: (id: string) => void,
  logger: Logger,
): boolean {
  const selection = $getSelection()
  if (!$isRangeSelection(selection)) {
    logger.info('Current selection is not range selection')
    return true
  }

  const isInitialSelectionBackward = selection.isBackward()

  logger.info('Is selection backward?', isInitialSelectionBackward, selection.anchor.offset, selection.focus.offset)

  const point = selection.focus
  const anchorBeforeInserting = {
    key: point.key,
    offset: point.offset,
    type: point.type,
  }

  const suggestionID = GenerateUUID()

  const isInitialSelectionNotCollapsed = !selection.isCollapsed()
  if (isInitialSelectionNotCollapsed) {
    $wrapSelectionInSuggestionNode(selection, selection.isBackward(), suggestionID, 'delete')
    onSuggestionCreation(suggestionID)
    logger.info('Wrapped non-collapsed selection as delete suggestion', suggestionID)
  }

  const latestSelection = $getSelection()
  if (!$isRangeSelection(latestSelection) || !latestSelection.isCollapsed()) {
    logger.info('Latest selection is not range selection or is not collapsed')
    return true
  }

  if (isInitialSelectionNotCollapsed && !isInitialSelectionBackward) {
    const point = latestSelection.focus
    anchorBeforeInserting.key = point.key
    anchorBeforeInserting.offset = point.offset
    anchorBeforeInserting.type = point.type
  }

  const allNodesAreInline = !nodes.some($isNodeNotInline)
  if (allNodesAreInline) {
    const suggestionNode = $createSuggestionNode(suggestionID, 'insert')
    suggestionNode.append(...nodes)
    latestSelection.insertNodes([suggestionNode])
    logger.info('Appended all nodes as one suggestion node as all nodes were inline')
    onSuggestionCreation(suggestionID)
    return true
  }

  const selectionBeforeInserting = latestSelection

  logger.info('Anchor before inserting:', anchorBeforeInserting)

  logger.info('Inserting nodes into latest selection')
  selectionBeforeInserting.insertNodes(nodes)

  const selectionAfterInserting = $getSelection()
  if (!$isRangeSelection(selectionAfterInserting) || !selectionAfterInserting.isCollapsed()) {
    throw new Error('Cannot ensure inserted nodes are marked as suggestion')
  }

  const anchorAfterInserting = selectionAfterInserting.anchor

  logger.info('Anchor after inserting:', anchorAfterInserting)

  const doesBeforeAnchorExist = $getNodeByKey(anchorBeforeInserting.key)?.isAttached()

  const selectionToMark = $createRangeSelection()
  if (doesBeforeAnchorExist) {
    logger.info('Anchor before insertion still exists, using that.')
    selectionToMark.anchor.set(anchorBeforeInserting.key, anchorBeforeInserting.offset, anchorBeforeInserting.type)
  } else {
    // This only seems to be the case when pasting in an empty paragraph
    // as internally Lexical seems to replace it with a new paragraph
    // which has a different key
    logger.info("Anchor before insertion doesn't exist, using first node")
    const firstNode = nodes[0]
    selectionToMark.anchor.set(firstNode.getKey(), 0, $isElementNode(firstNode) ? 'element' : 'text')
  }
  selectionToMark.focus.set(anchorAfterInserting.key, anchorAfterInserting.offset, anchorAfterInserting.type)
  logger.info('Selection to wrap:', selectionToMark)

  $wrapSelectionInSuggestionNode(selectionToMark, selectionToMark.isBackward(), suggestionID, 'insert')
  onSuggestionCreation(suggestionID)
  logger.info('Wrapped selection in suggestion', suggestionID)

  return true
}
