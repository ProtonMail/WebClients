import { sha1 } from '@noble/hashes/sha1';
import { bytesToHex } from '@noble/hashes/utils';
import { c } from 'ttag';

import type { NodeEntity, ProtonDrivePublicLinkClient } from '@proton/drive/index';

import { DownloadStatus, IssueStatus, useDownloadManagerStore } from '../../../zustand/download/downloadManager.store';
import { downloadLogDebug } from '../utils/downloadLogger';
import { getDownloadSdk } from '../utils/getDownloadSdk';

type DecisionState = {
    decisionPromise: Promise<IssueStatus>;
    resolve: (decision: IssueStatus) => void;
};

const defaultMessage = c('Info').t`Computed hash does not match XAttr`;

export class MalwareDetection {
    private readonly pendingDecisions = new Map<string, DecisionState>();

    private createDecisionPromise(
        downloadId: string,
        node: NodeEntity,
        message?: string
    ): DecisionState['decisionPromise'] {
        let resolve: (decision: IssueStatus) => void = () => undefined;
        const decisionPromise = new Promise<IssueStatus>((res) => {
            resolve = res;
        });
        const { updateDownloadItem } = useDownloadManagerStore.getState();
        const deferred = { decisionPromise, resolve };

        this.pendingDecisions.set(downloadId, deferred);
        updateDownloadItem(downloadId, {
            malwareDetectionStatus: IssueStatus.Detected,
            status: DownloadStatus.MalwareDetected,
            malwareInfo: {
                name: node.name,
                message: message ?? defaultMessage,
                mediaType: node.mediaType ?? 'unknown',
                uid: node.uid,
                size: node.totalStorageSize ?? 0,
            },
        });

        return deferred.decisionPromise;
    }

    private static getClaimedHash(node: NodeEntity) {
        return node.activeRevision?.claimedDigests?.sha1;
    }

    private async scanHashForMalware(
        downloadId: string,
        node: NodeEntity,
        computedHash?: string
    ): Promise<Promise<IssueStatus> | undefined> {
        const hash = computedHash ? computedHash : MalwareDetection.getClaimedHash(node);
        if (!hash) {
            // in this case it will check again at the end of download using the computed hash
            return undefined;
        }

        // Right now this method only exists on public client and will only be used in public context
        const drive = getDownloadSdk(downloadId) as ProtonDrivePublicLinkClient;
        const scanHashes = drive.experimental?.scanHashes;

        if (typeof scanHashes !== 'function') {
            downloadLogDebug('Malware scan skipped: scanHashes unavailable on client', {
                downloadId,
                nodeUid: node.uid,
            });
            throw new Error('scanHashes unavailable on client');
        }

        const scanResult = await scanHashes([hash]);

        if (!scanResult[hash].safe) {
            return this.createDecisionPromise(downloadId, node, scanResult[hash].error);
        }

        return undefined;
    }

    private async verifyClaimedHash(
        downloadId: string,
        node: NodeEntity,
        computedHash: string
    ): Promise<Promise<IssueStatus> | undefined> {
        // Only perform if a malware was not already found in the previous scanHashForMalware stage
        if (!this.pendingDecisions.get(downloadId)) {
            if (computedHash !== MalwareDetection.getClaimedHash(node)) {
                // Check that computed and claimed hashes match
                return this.createDecisionPromise(downloadId, node, defaultMessage);
            } else if (!MalwareDetection.getClaimedHash(node)) {
                // If claimed hash is not there we do a malware check on the computed hash instead
                return this.scanHashForMalware(downloadId, node, computedHash);
            }
        }
        return undefined;
    }

    private async getPendingDecisionPromise(downloadId: string) {
        const decision = await this.pendingDecisions.get(downloadId)?.decisionPromise;
        return decision;
    }

    /**
     * Wraps a stream with malware detection. Both stage 1 (claimed hash) and stage 2 (computed hash)
     * checks happen automatically via the stream transform.
     * Returns the wrapped stream.
     */
    wrapStream(
        downloadId: string,
        node: NodeEntity,
        stream: ReadableStream<Uint8Array<ArrayBuffer>>
    ): ReadableStream<Uint8Array<ArrayBuffer>> {
        const { getQueueItem } = useDownloadManagerStore.getState();
        const queueItem = getQueueItem(downloadId);

        if (!queueItem?.shouldScanForMalware) {
            return stream;
        }

        const hashInstance = sha1.create();
        let stage1Complete = false;

        const transform = new TransformStream<Uint8Array<ArrayBuffer>, Uint8Array<ArrayBuffer>>({
            start: async () => {
                // Stage 1: Check malware using claimed hash from metadata
                await this.scanHashForMalware(downloadId, node);
                await this.getPendingDecisionPromise(downloadId);
                stage1Complete = true;
            },
            transform: (chunk, controller) => {
                // Compute hash incrementally while passing chunks through
                hashInstance.update(chunk);
                controller.enqueue(chunk);
            },
            flush: async () => {
                if (!stage1Complete) {
                    return;
                }

                // Stage 2: Check malware using computed hash for integrity
                const computedHash = bytesToHex(hashInstance.digest());
                await this.verifyClaimedHash(downloadId, node, computedHash);
                await this.getPendingDecisionPromise(downloadId);
            },
        });

        return stream.pipeThrough(transform);
    }

    resolveDecision(downloadId: string, decision: IssueStatus) {
        const { updateDownloadItem } = useDownloadManagerStore.getState();
        updateDownloadItem(downloadId, {
            malwareDetectionStatus: decision,
            ...(decision === IssueStatus.Approved && { status: DownloadStatus.InProgress }),
        });
        const decisionState = this.pendingDecisions.get(downloadId);
        decisionState?.resolve(decision);
        this.pendingDecisions.delete(downloadId);
    }

    rejectPending(downloadId: string) {
        const decisionState = this.pendingDecisions.get(downloadId);
        decisionState?.resolve(IssueStatus.Rejected);
        this.pendingDecisions.delete(downloadId);
    }
}
