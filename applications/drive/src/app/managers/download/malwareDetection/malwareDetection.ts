import type { NodeEntity, ProtonDrivePublicLinkClient } from '@proton/drive/index';

import { DownloadStatus, IssueStatus, useDownloadManagerStore } from '../../../zustand/download/downloadManager.store';
import { downloadLogDebug } from '../utils/downloadLogger';
import { getDownloadSdk } from '../utils/getDownloadSdk';

type DecisionState = {
    decisionPromise: Promise<IssueStatus>;
    resolve: (decision: IssueStatus) => void;
};

export class MalwareDetection {
    private readonly pendingDecisions = new Map<string, DecisionState>();

    private createDecisionPromise(): DecisionState {
        let resolve: (decision: IssueStatus) => void = () => undefined;
        const decisionPromise = new Promise<IssueStatus>((res) => {
            resolve = res;
        });
        return { decisionPromise, resolve };
    }

    getClaimedHash(node: NodeEntity) {
        return node.activeRevision?.claimedDigests?.sha1;
    }

    async checkMalware(downloadId: string, node: NodeEntity): Promise<Promise<IssueStatus> | undefined> {
        const { updateDownloadItem } = useDownloadManagerStore.getState();

        const hash = this.getClaimedHash(node);
        if (!hash) {
            // TODO: do this check again with the computed hash in this case
            return undefined;
        }

        // Right now this method only exists on public client and will only be used in public context
        const drive = getDownloadSdk(downloadId) as ProtonDrivePublicLinkClient;
        const scanHashes = drive.experimental?.scanHashes;

        if (typeof scanHashes !== 'function') {
            downloadLogDebug('Malware scan skipped: scanHashes unavailable on client', {
                downloadId,
                nodeUid: node.uid,
            });
            throw new Error('scanHashes unavailable on client');
        }

        const scanResult = await scanHashes([hash]);

        if (!scanResult[hash].safe) {
            const deferred = this.createDecisionPromise();
            this.pendingDecisions.set(downloadId, deferred);
            updateDownloadItem(downloadId, {
                malwareDetectionStatus: IssueStatus.Detected,
                status: DownloadStatus.MalwareDetected,
                malwareInfo: {
                    name: node.name,
                    message: scanResult[hash].error,
                    mediaType: node.mediaType ?? 'unknown',
                    uid: node.uid,
                    size: node.totalStorageSize ?? 0,
                },
            });
            return deferred.decisionPromise;
        }

        return undefined;
    }

    async getPendingDecisionPromise(downloadId: string) {
        const decision = await this.pendingDecisions.get(downloadId)?.decisionPromise;
        return decision;
    }

    resolveDecision(downloadId: string, decision: IssueStatus) {
        const { updateDownloadItem } = useDownloadManagerStore.getState();
        updateDownloadItem(downloadId, { malwareDetectionStatus: decision });
        const decisionState = this.pendingDecisions.get(downloadId);
        decisionState?.resolve(decision);
        this.pendingDecisions.delete(downloadId);
    }

    rejectPending(downloadId: string) {
        const decisionState = this.pendingDecisions.get(downloadId);
        decisionState?.resolve(IssueStatus.Rejected);
        this.pendingDecisions.delete(downloadId);
    }
}
