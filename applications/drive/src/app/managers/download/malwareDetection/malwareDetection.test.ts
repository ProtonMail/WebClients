import { jest } from '@jest/globals';

import type { NodeEntity } from '@proton/drive/index';

import { createMockNodeEntity } from '../../../utils/test/nodeEntity';
import { DownloadStatus, IssueStatus } from '../../../zustand/download/downloadManager.store';

type MockStoreState = { updateDownloadItem: jest.Mock };
type ScanHashesResult = Record<string, { safe: boolean; error?: string }>;
type ScanHashesFn = (hashes: string[]) => Promise<ScanHashesResult>;
type ScanHashesMock = jest.MockedFunction<ScanHashesFn>;

const getDownloadSdkMock = jest.fn();
const downloadLogDebugMock = jest.fn();
const mockStoreState: MockStoreState = {
    updateDownloadItem: jest.fn(),
};

jest.mock('../utils/getDownloadSdk', () => ({
    getDownloadSdk: (...args: unknown[]) => getDownloadSdkMock(...args),
}));

jest.mock('../utils/downloadLogger', () => ({
    downloadLogDebug: (...args: unknown[]) => downloadLogDebugMock(...args),
}));

jest.mock('../../../zustand/download/downloadManager.store', () => {
    const actual = jest.requireActual('../../../zustand/download/downloadManager.store') as Record<string, unknown>;
    return {
        ...actual,
        useDownloadManagerStore: {
            getState: jest.fn(() => ({
                ...mockStoreState,
                getQueueItem: jest.fn(() => ({ shouldScanForMalware: true })),
            })),
        },
    };
});

const { MalwareDetection } = require('./malwareDetection');

function createNodeWithHash(hash: string, overrides: Partial<NodeEntity> = {}): NodeEntity {
    const node = createMockNodeEntity(overrides);
    return {
        ...node,
        activeRevision: node.activeRevision
            ? {
                  ...node.activeRevision,
                  claimedDigests: { sha1: hash },
              }
            : undefined,
    };
}

function createScanHashesMock(result: ScanHashesResult): ScanHashesMock {
    const mock = jest.fn<ScanHashesFn>();
    mock.mockResolvedValue(result);
    return mock;
}

describe('MalwareDetection', () => {
    let malwareDetection: InstanceType<typeof MalwareDetection>;

    beforeEach(() => {
        jest.clearAllMocks();
        malwareDetection = new MalwareDetection();
        mockStoreState.updateDownloadItem.mockClear();
    });

    it('throws when claimed hash token is missing', async () => {
        const baseNode = createMockNodeEntity();
        const node: NodeEntity = {
            ...baseNode,
            activeRevision: baseNode.activeRevision
                ? {
                      ...baseNode.activeRevision,
                      claimedDigests: undefined,
                  }
                : undefined,
        };

        await expect(malwareDetection.scanHashForMalware('download-id', node)).resolves.toBeUndefined();
        expect(getDownloadSdkMock).not.toHaveBeenCalled();
    });

    it('throws when scanHashes is unavailable', async () => {
        const downloadId = 'download-hashless';
        const node = createNodeWithHash('hash-123');
        getDownloadSdkMock.mockReturnValue({ experimental: {} });

        await expect(malwareDetection.scanHashForMalware(downloadId, node)).rejects.toThrow(
            'scanHashes unavailable on client'
        );

        expect(getDownloadSdkMock).toHaveBeenCalledWith(downloadId);
        expect(downloadLogDebugMock).toHaveBeenCalledWith('Malware scan skipped: scanHashes unavailable on client', {
            downloadId,
            nodeUid: node.uid,
        });
        expect(mockStoreState.updateDownloadItem).not.toHaveBeenCalled();
    });

    it('skips reporting when scan result is safe', async () => {
        const downloadId = 'download-safe';
        const node = createNodeWithHash('hash-safe');
        const scanHashesMock = createScanHashesMock({
            'hash-safe': { safe: true },
        });
        getDownloadSdkMock.mockReturnValue({ experimental: { scanHashes: scanHashesMock } });

        const result = await malwareDetection.scanHashForMalware(downloadId, node);

        expect(result).toBeUndefined();
        expect(scanHashesMock).toHaveBeenCalledWith(['hash-safe']);
        expect(mockStoreState.updateDownloadItem).not.toHaveBeenCalled();
    });

    it('reports enriched error and tracks pending decision when malware is detected', async () => {
        const downloadId = 'download-malware';
        const node = createNodeWithHash('hash-danger', {
            uid: 'node-42',
            name: 'virus.bin',
            mediaType: 'application/x-msdownload',
            totalStorageSize: 4096,
        });
        const scanHashesMock = createScanHashesMock({
            'hash-danger': { safe: false, error: 'Detected threat' },
        });
        getDownloadSdkMock.mockReturnValue({ experimental: { scanHashes: scanHashesMock } });

        const decisionPromise = malwareDetection.scanHashForMalware(downloadId, node);
        await Promise.resolve();
        expect(scanHashesMock).toHaveBeenCalledWith(['hash-danger']);

        expect(mockStoreState.updateDownloadItem).toHaveBeenCalledWith(
            downloadId,
            expect.objectContaining({
                malwareDetectionStatus: IssueStatus.Detected,
                status: DownloadStatus.MalwareDetected,
                malwareInfo: {
                    name: node.name,
                    message: 'Detected threat',
                    mediaType: node.mediaType,
                    uid: node.uid,
                    size: node.totalStorageSize,
                },
            })
        );

        malwareDetection.resolveDecision(downloadId, IssueStatus.Approved);

        await expect(decisionPromise).resolves.toBe(IssueStatus.Approved);
        expect(mockStoreState.updateDownloadItem).toHaveBeenLastCalledWith(downloadId, {
            malwareDetectionStatus: IssueStatus.Approved,
        });
    });

    describe('wrapStream', () => {
        it('should return original stream when scanning is disabled', () => {
            const stream = new ReadableStream();
            const node = createNodeWithHash('hash-123');

            mockStoreState.updateDownloadItem.mockClear();
            const { useDownloadManagerStore } = require('../../../zustand/download/downloadManager.store');
            useDownloadManagerStore.getState.mockReturnValue({
                ...mockStoreState,
                getQueueItem: jest.fn(() => ({ shouldScanForMalware: false })),
            });

            const wrappedStream = malwareDetection.wrapStream('download-disabled', node, stream);

            expect(wrappedStream).toBe(stream);
        });

        it('should wrap stream with malware detection transform', () => {
            const stream = new ReadableStream();
            const node = createNodeWithHash('hash-123');

            mockStoreState.updateDownloadItem.mockClear();
            const { useDownloadManagerStore } = require('../../../zustand/download/downloadManager.store');
            useDownloadManagerStore.getState.mockReturnValue({
                ...mockStoreState,
                getQueueItem: jest.fn(() => ({ shouldScanForMalware: true })),
            });

            const scanHashesMock = createScanHashesMock({ 'hash-123': { safe: true } });
            getDownloadSdkMock.mockReturnValue({
                experimental: { scanHashes: scanHashesMock },
            });

            const wrappedStream = malwareDetection.wrapStream('download-wrapped', node, stream);

            expect(wrappedStream).toBeInstanceOf(ReadableStream);
            expect(wrappedStream).not.toBe(stream);
        });
    });
});
