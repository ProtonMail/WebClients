import { useState } from 'react';

import { useAssistantSubscriptionStatus, useUserSettings } from '@proton/components/hooks';
import useAssistantTelemetry from '@proton/components/hooks/assistant/useAssistantTelemetry';
import { useAssistant } from '@proton/llm/lib';
import type {
    Action,
    ActionType,
    PartialRefineAction,
    RefineAction,
    RefineActionType,
    RefineLocation,
} from '@proton/llm/lib/types';
import { isPredefinedRefineActionType, isRefineActionType } from '@proton/llm/lib/types';
import type { Recipient } from '@proton/shared/lib/interfaces';
import { AI_ASSISTANT_ACCESS } from '@proton/shared/lib/interfaces';

import type { ReplacementStyle } from 'proton-mail/components/assistant/ComposerAssistant';
import { removeLineBreaks } from 'proton-mail/helpers/string';

export interface GenerateResultProps {
    actionType?: ActionType;
    setShouldShowRefineButtons?: (value: boolean) => void;
    assistantRequest: string;
    setAssistantRequest?: (value: string) => void;
}

interface Props {
    assistantID: string;
    showAssistantSettingsModal: () => void;
    showResumeDownloadModal: () => void;
    showUpsellModal: () => void;
    onResetSelection: () => void;
    expanded: boolean;
    hasSelection: boolean;
    recipients: Recipient[];
    sender: Recipient | undefined;
    getContentBeforeBlockquote: () => string;
    checkScrollButtonDisplay: () => boolean | undefined;
    selectedText: string | undefined;
    inputSelectedText: string;
    onUseGeneratedText: (value: string) => void;
    onUseRefinedText: (value: string) => void;
    setContentBeforeBlockquote: (content: string) => void;
}

const useComposerAssistantGenerate = ({
    assistantID,
    showAssistantSettingsModal,
    showResumeDownloadModal,
    showUpsellModal,
    onResetSelection,
    expanded,
    hasSelection,
    recipients,
    sender,
    getContentBeforeBlockquote,
    checkScrollButtonDisplay,
    selectedText,
    inputSelectedText,
    onUseGeneratedText,
    onUseRefinedText,
    setContentBeforeBlockquote,
}: Props) => {
    const [generationResult, setGenerationResult] = useState('');
    const [replacementStyle, setReplacementStyle] = useState<ReplacementStyle>(
        inputSelectedText ? 'refineSelectedText' : undefined
    );
    const [isRefiningText, setIsRefiningText] = useState(false);
    const [submittedPrompt, setSubmittedPrompt] = useState('');

    const [{ AIAssistantFlags }] = useUserSettings();
    const { trialStatus, start: startTrial } = useAssistantSubscriptionStatus();
    const { downloadPaused, generateResult, closeAssistant } = useAssistant(assistantID);
    const { sendUseAnswerAssistantReport } = useAssistantTelemetry();

    const handleStartTrial = () => {
        let trialStarted = false;
        if (!trialStarted && trialStatus === 'trial-not-started') {
            trialStarted = true;
            void startTrial();
        }
    };

    const handleSetResult = (text: string) => {
        setGenerationResult(text);
        checkScrollButtonDisplay();
    };

    const handleSetGenerationResult = (fulltext: string, prompt?: string): void => {
        handleStartTrial();
        handleSetResult(fulltext);
        setSubmittedPrompt(prompt ?? '');
    };

    /* Refine with selection */

    const handleRefineEditorContent = async (partialAction: PartialRefineAction) => {
        if (selectedText) {
            /** There are 2 types of refine
             * 1- Refine text that is selected in the editor
             *      => We have a selected text in the editor
             *          && there is no result generated (otherwise, we are trying to refine a generated text, and we fall in the 2nd case)
             * 2- Refine selection of the text generated by the assistant. The user wants to improve it before inserting it.
             */
            if (inputSelectedText && !generationResult) {
                /** In the first case, when we have an input selected text (text coming from the editor),
                 * we can add the entire generated text inside the assistant result.
                 * To generate a result, we are sending to the llm manager:
                 * - The refine prompt
                 * - The full email in plaintext
                 * - The start and end index of the selection within the full email
                 */
                const plain = removeLineBreaks(getContentBeforeBlockquote());
                const idxStart = plain.indexOf(removeLineBreaks(selectedText));
                const idxEnd = idxStart + removeLineBreaks(selectedText).length;

                const action: RefineAction = {
                    ...partialAction,
                    fullEmail: plain,
                    idxStart,
                    idxEnd,
                };
                await generateResult({
                    action,
                    callback: (res) => handleSetGenerationResult(res),
                });
            } else {
                /** In the second case, when we want to refine selection of the text generated by the assistant before importing it,
                 * we don't want to erase the full assistant result while generating.
                 * We want to replace the part that is being refined.
                 * In that case, we will get the text before the selection and the text after the selection so that we can replace
                 * the old text with the new generated text.
                 * To generate a result, we are sending to the llm manager:
                 * - The refine prompt
                 * - The previous generated text
                 * - The start and end index of the selection within the previous generated text
                 */
                const idxStart = generationResult.indexOf(selectedText);
                const idxEnd = idxStart + selectedText.length;
                const beforeSelection = generationResult.slice(0, idxStart);
                const afterSelection = generationResult.slice(idxEnd, generationResult.length);

                const handleInsertRefineInGenerationResult = (textToReplace: string) => {
                    handleStartTrial();
                    const newResult = `${beforeSelection}${textToReplace}${afterSelection}`;
                    handleSetResult(newResult);
                };

                const action = {
                    ...partialAction,
                    fullEmail: generationResult,
                    idxStart,
                    idxEnd,
                };
                await generateResult({
                    action,
                    callback: handleInsertRefineInGenerationResult,
                });
            }
        }
    };

    const refineWithSelection = async (assistantRequest: string, actionType: RefineActionType) => {
        let partialAction: PartialRefineAction;
        if (isPredefinedRefineActionType(actionType)) {
            partialAction = {
                type: actionType,
            };
        } else {
            partialAction = {
                type: actionType,
                prompt: assistantRequest,
            };
        }

        await handleRefineEditorContent(partialAction); // refine location (idxStart/idxEnd) is set later
    };

    /* Generation related */
    const getEmailContentsForRefinement = () => {
        const composerContent = removeLineBreaks(getContentBeforeBlockquote());
        if (expanded && generationResult) {
            return generationResult;
        } else if (composerContent) {
            return composerContent;
        }
    };

    const buildAction = (assistantRequest: string, actionType: ActionType): Action | undefined => {
        if (actionType === 'writeFullEmail') {
            return {
                type: 'writeFullEmail',
                prompt: assistantRequest,
                recipient: recipients?.[0]?.Name,
                sender: sender?.Name,
            };
        }

        const fullEmail = getEmailContentsForRefinement();
        if (!fullEmail) {
            return undefined;
        }

        const refineLocation: RefineLocation = {
            fullEmail,
            idxStart: 0,
            idxEnd: fullEmail.length,
        };

        // Predefined refine (shorten, proofread etc)
        if (isPredefinedRefineActionType(actionType)) {
            return {
                type: actionType,
                ...refineLocation,
            };
        }

        // Custom refine (with user prompt)
        return {
            type: actionType,
            prompt: assistantRequest,
            ...refineLocation,
        };
    };

    const detectReplacementStyle = (actionType: ActionType): ReplacementStyle | undefined => {
        const hasGeneratedText = expanded && !!generationResult;
        const isRefine = isRefineActionType(actionType);

        if (hasSelection && !generationResult) {
            return 'refineSelectedText';
        }
        if (!hasSelection && !hasGeneratedText && isRefine) {
            return 'refineFullMessage';
        }
        if (!hasSelection && !generationResult && !isRefine) {
            return 'generateFullMessage';
        }
        return undefined;
    };

    const generate = async ({
        actionType,
        setShouldShowRefineButtons,
        setAssistantRequest,
        assistantRequest,
    }: GenerateResultProps) => {
        // If user hasn't set the assistant yet, invite him to do so
        if (AIAssistantFlags === AI_ASSISTANT_ACCESS.UNSET) {
            showAssistantSettingsModal();
            return;
        }

        // Warn the user that we need the download to be completed before generating a result
        if (downloadPaused) {
            showResumeDownloadModal();
            return;
        }

        // Stop if trial ended
        if (trialStatus === 'trial-ended') {
            showUpsellModal();
            return;
        }

        // Unselect text (may take effect later, due to useState?)
        onResetSelection();

        // If actionType is undefined, it means we're being called with a user request
        // (user has typed stuff the AI input field), but caller doesn't know if this
        // has to be applied to full message generation or refinement of a specific part.
        if (!actionType) {
            actionType = hasSelection ? 'customRefine' : 'writeFullEmail';
        }

        // Figure out which replacement style must be used to insert the new content
        const replacementStyle = detectReplacementStyle(actionType);
        if (replacementStyle) {
            setReplacementStyle(replacementStyle);
        }

        const generateType = (() => {
            const isRefineAction = isRefineActionType(actionType);
            if (isRefineAction && hasSelection) {
                return 'refine-with-selection';
            }
            if (isRefineAction) {
                return 'refine';
            }

            return 'generate';
        })();

        if (generateType === 'refine-with-selection') {
            setIsRefiningText(true);
            await refineWithSelection(assistantRequest, actionType as RefineActionType);
        }

        if (generateType === 'refine') {
            setIsRefiningText(true);

            // Empty the user request field after they typed Enter
            setAssistantRequest?.('');

            const action = buildAction(assistantRequest, actionType);
            if (action) {
                await generateResult({
                    action,
                    callback: (res) => {
                        handleSetGenerationResult(res, assistantRequest);
                    },
                });
            }
        }

        if (generateType === 'generate') {
            const action = buildAction(assistantRequest, actionType);
            if (action) {
                await generateResult({
                    action,
                    callback: (res) => {
                        handleSetGenerationResult(res, assistantRequest);
                    },
                });
            }
        }

        setIsRefiningText(false);
        setShouldShowRefineButtons?.(true);
    };

    /* Insert generation in composer */

    // This function defines what happens when the user commits the proposed generation with the button "Use this".
    const replaceMessageBody = async () => {
        /**
         * There are 3 different usages of the generated text:
         * 1- Insert text at the beginning of the composer, when there is no selected text in the editor
         * 2- Replace text in the composer where the current selection is
         * 3- Replace the full message body (signature and blockquote excluded)
         */
        if (replacementStyle === 'generateFullMessage') {
            onUseGeneratedText(generationResult);
            sendUseAnswerAssistantReport();
        }

        if (replacementStyle === 'refineSelectedText') {
            onUseRefinedText(generationResult);
            sendUseAnswerAssistantReport();
        }

        if (replacementStyle === 'refineFullMessage') {
            setContentBeforeBlockquote(generationResult);
            sendUseAnswerAssistantReport();
        }

        // TODO: replace this later
        if (replacementStyle === undefined) {
            throw new Error('replacementStyle is undefined');
        }

        setReplacementStyle(undefined);

        closeAssistant(assistantID);
    };

    return {
        generationResult,
        generate,
        replaceMessageBody,
        isRefiningText,
        submittedPrompt,
        setReplacementStyle,
    };
};

export default useComposerAssistantGenerate;
