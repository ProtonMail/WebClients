PROJECT_PATH = "Proton Pass Extensions.xcodeproj"
BUILD_PATH = "build"
KEYCHAIN_NAME = "me.proton.pass.electron.keychain"
KEYCHAIN_PATH = File.expand_path("~/Library/Keychains/#{KEYCHAIN_NAME}-db")
MAS_PATH = File.expand_path("../../mas", __dir__)

def delete_keychain_if_exists
  delete_keychain(keychain_path: KEYCHAIN_PATH)
rescue => e
  UI.message("Keychain #{KEYCHAIN_NAME} not found or already deleted, skipping")
end

desc "Bump version from VERSION environment variable"
lane :bump_version do
  version = ENV["VERSION"]
  UI.user_error!("VERSION environment variable is not set") if version.nil? || version.empty?

  project = Xcodeproj::Project.open("../#{PROJECT_PATH}")
  project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings["MARKETING_VERSION"] = version
    end
  end
  project.save

  UI.success("Version updated to #{version}")
end

desc "Bump build number from BUILD_NUMBER environment variable"
lane :bump_build_number do
  build_number = ENV["BUILD_NUMBER"]
  UI.user_error!("BUILD_NUMBER environment variable is not set") if build_number.nil? || build_number.empty?

   increment_build_number(
    xcodeproj: PROJECT_PATH,
    build_number: build_number
  )

  UI.success("Build number updated to #{build_number}")
end

desc "Load App Store Connect API Key information to use in subsequent lanes"
lane :load_asc_api_key do
    app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_KEY"]
    )
end

desc "Get next build number"
lane :get_next_build_number do
  load_asc_api_key
  api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

  # Get latest build number from TestFlight
  latest_build_number = latest_testflight_build_number(
    api_key: api_key,
    app_identifier: "me.proton.pass.electron",
    platform: "osx"
  )
  next_build_number = latest_build_number + 1

  UI.message("Next build number is #{next_build_number}")
  next_build_number
end

desc "Build and sign the macOS app for App Store"
  lane :build_mas do
    sh("rm -rf #{BUILD_PATH}")
    FileUtils.mkdir_p(BUILD_PATH)

    # Install provisioning profiles for the host app and its extensions
    install_provisioning_profile(path: "#{MAS_PATH}/MacAppStore.provisionprofile")
    install_provisioning_profile(path: "#{MAS_PATH}/AutoFillAppStore.provisionprofile")

    # Add the signing certificates to a separate keychain (don't touch default)
    keychain_password = ENV["KEYCHAIN_PASSWORD"]
    delete_keychain_if_exists
    create_keychain(
      name: KEYCHAIN_NAME,
      password: keychain_password,
      default_keychain: false,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false,
      lock_after_timeout: false,
      add_to_search_list: true
    )

    import_certificate(
      certificate_path: "#{MAS_PATH}/installer.p12",
      certificate_password: ENV["INSTALLER_CERT_PASSWORD"],
      keychain_path: KEYCHAIN_PATH,
      keychain_password: keychain_password
    )

    import_certificate(
      certificate_path: "#{MAS_PATH}/app.p12",
      certificate_password: ENV["APP_CERT_PASSWORD"],
      keychain_path: KEYCHAIN_PATH,
      keychain_password: keychain_password
    )

    # Ensure our keychain is first in the search list so codesign finds the certs
    existing_keychains = `security list-keychains -d user`.split("\n").map { |k| k.strip.gsub('"', '') }
    search_list = [KEYCHAIN_PATH] + existing_keychains.reject { |k| k == KEYCHAIN_PATH }
    `security list-keychains -d user -s #{search_list.map { |k| %Q("#{k}") }.join(' ')}`
    UI.message("Keychain search list: #{`security list-keychains -d user`}")

    gym(
      project: PROJECT_PATH,
      scheme: "Proton Pass Extensions",
      clean: true,
      output_directory: BUILD_PATH,
      output_name: "Proton Pass",
      export_method: "app-store",
      destination: "generic/platform=macOS",
      configuration: "Release",
      archive_path: "#{BUILD_PATH}/Proton Pass.xcarchive",
      export_options: {
        method: "app-store",
        signingStyle: "manual",
        provisioningProfiles: {
          "me.proton.pass.electron" => "Proton Pass Electron",
          "me.proton.pass.electron.autofill" => "Proton Pass Electron AutoFill"
        }
      }
    )

    UI.success("Build completed! App available at #{BUILD_PATH}/Proton Pass.app")
    delete_keychain_if_exists
    UI.success("Deleted keychain #{KEYCHAIN_NAME}")
  end

desc "Upload PKG to TestFlight"
lane :upload_pkg_to_testflight do
  load_asc_api_key
  api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

  # Find the PKG file in the dist/mas-universal directory
  pkg_dir = File.expand_path("../../dist/mas-universal", __dir__)
  pkg_files = Dir.glob("#{pkg_dir}/*.pkg")

  UI.user_error!("No PKG file found in #{pkg_dir}") if pkg_files.empty?
  UI.user_error!("Multiple PKG files found in #{pkg_dir}, please ensure only one PKG exists") if pkg_files.length > 1

  pkg_path = pkg_files.first
  UI.message("Uploading PKG: #{pkg_path}")

  upload_to_testflight(
    api_key: api_key,
    skip_submission: true,
    skip_waiting_for_build_processing: true,
    pkg: pkg_path
  )

  UI.success("Successfully uploaded #{pkg_path} to TestFlight")
end