import type { Attachment, ContentBlock, Message } from '../types';
import { countTokens } from './tokenizer';

/**
 * Calculate token count for a single content block.
 * Delegates to appropriate calculation based on block type.
 */
function calculateBlockTokens(block: ContentBlock): number {
    switch (block.type) {
        case 'text':
            return countTokens(block.content);
        case 'tool_call':
            return countTokens(block.content);
        case 'tool_result':
            return countTokens(block.content);
        default:
            // Future-proof: unknown block types
            return 0;
    }
}

/**
 * Calculate tokens from message content only (excluding context)
 * Used for UI components that need to show message content tokens separately
 */
export const calculateMessageContentTokens = (messageChain: Message[]): number => {
    return messageChain.reduce((total, message) => {
        if (message.blocks && message.blocks.length > 0) {
            // New format: iterate through blocks and delegate to helper
            return total + message.blocks.reduce((sum, block) => sum + calculateBlockTokens(block), 0);
        } else {
            // Legacy format
            return (
                total + countTokens(message.content) + countTokens(message.toolCall) + countTokens(message.toolResult)
            );
        }
    }, 0);
};

// Calculate estimated tokn size for a single attachment
export const countAttachmentToken = (attachment: Attachment): number => {
    if (!attachment || attachment.processing || !attachment.markdown || !attachment.filename) {
        return 0;
    }

    // Use cached token count if available (for performance)
    if (attachment.tokenCount !== undefined && attachment.tokenCount > 0) {
        return attachment.tokenCount;
    }

    try {
        // Calculate the context that would be generated by flattenAttachmentsForLlm for this file
        const filename = `Filename: ${attachment.filename}`;
        const header = 'File contents:';
        const beginMarker = '----- BEGIN FILE CONTENTS -----';
        const endMarker = '----- END FILE CONTENTS -----';
        const content = attachment.markdown.trim();

        const fullContext = [filename, header, beginMarker, content, endMarker].join('\n');

        // Use fast approximation for better performance (4 chars/token)
        return countTokens(fullContext);
    } catch (error) {
        console.warn('Error calculating attachment context size:', error, attachment);
        return 0;
    }
};

/**
 * Calculate estimated token size for attachments based on their markdown content.
 * This function simulates the token cost of what would be sent to the LLM.
 *
 * @param attachments Array of attachments to calculate context size for
 * @returns Total estimated token count for all attachments
 */
export const calculateAttachmentContextSize = (attachments: Attachment[]): number => {
    return attachments.reduce((total, attachment) => {
        return total + countAttachmentToken(attachment);
    }, 0);
};

// Context window limits (approximate)
export const CONTEXT_LIMITS = {
    WARNING_THRESHOLD: 90000, // Start warning at ~24K tokens
    DANGER_THRESHOLD: 100000, // Strong warning at ~48K tokens
    MAX_CONTEXT: 128000, // Typical context window limit
} as const;

export const getContextSizeWarning = (tokenCount: number): 'none' | 'warning' | 'danger' | 'critical' => {
    if (tokenCount >= CONTEXT_LIMITS.MAX_CONTEXT) {
        return 'critical';
    } else if (tokenCount >= CONTEXT_LIMITS.DANGER_THRESHOLD) {
        return 'danger';
    } else if (tokenCount >= CONTEXT_LIMITS.WARNING_THRESHOLD) {
        return 'warning';
    }
    return 'none';
};

export const formatTokenCount = (tokenCount: number): string => {
    if (tokenCount < 1000) {
        return `${Math.round(tokenCount)} tokens`;
    } else {
        return `${(tokenCount / 1000).toFixed(1)}K tokens`;
    }
};

// Get size level for individual files
export const getFileSizeLevel = (tokenCount: number): 'small' | 'medium' | 'large' | 'very-large' => {
    if (tokenCount >= 20000) {
        // Very large single file
        return 'very-large';
    } else if (tokenCount >= 10000) {
        // Large single file
        return 'large';
    } else if (tokenCount >= 5000) {
        // Medium single file
        return 'medium';
    }
    return 'small';
};

// Get context usage percentage (0-100)
export const getContextUsagePercentage = (tokenCount: number): number => {
    return Math.min(100, Math.round((tokenCount / CONTEXT_LIMITS.MAX_CONTEXT) * 100));
};

// Get progress bar state for visual indicators
export const getContextProgressState = (percentage: number): 'low' | 'medium' | 'high' | 'critical' => {
    if (percentage >= 100) {
        return 'critical';
    } else if (percentage >= 75) {
        return 'high';
    } else if (percentage >= 50) {
        return 'medium';
    }
    return 'low';
};

// Calculate total context size including conversation history and current attachments
export const calculateTotalContextSize = (messageChain: Message[], currentAttachments: Attachment[]): number => {
    const conversationContext = calculateConversationContextSize(messageChain);
    const currentAttachmentsContext = calculateAttachmentContextSize(currentAttachments);
    return conversationContext + currentAttachmentsContext;
};

// Calculate context size for the conversation history (messages + their attachments)
export const calculateConversationContextSize = (messageChain: Message[]): number => {
    return messageChain.reduce((total, message) => {
        // Calculate content tokens from blocks if available, otherwise use legacy fields
        let contentTokens = 0;
        if (message.blocks && message.blocks.length > 0) {
            // New format: iterate through blocks and delegate to helper
            contentTokens = message.blocks.reduce((sum, block) => sum + calculateBlockTokens(block), 0);
        } else {
            // Legacy format
            contentTokens =
                countTokens(message.content) + countTokens(message.toolCall) + countTokens(message.toolResult);
        }

        // Context from attachments in this message (already formatted by flattenAttachmentsForLlm)
        const contextTokens = countTokens(message.context);

        return total + contentTokens + contextTokens;
    }, 0);
};

// Get context breakdown for display
export const getContextBreakdown = (messageChain: Message[], currentAttachments: Attachment[]) => {
    const conversationSize = calculateConversationContextSize(messageChain);
    const currentAttachmentsSize = calculateAttachmentContextSize(currentAttachments);
    const totalSize = conversationSize + currentAttachmentsSize;

    return {
        conversationSize,
        currentAttachmentsSize,
        totalSize,
        conversationPercentage: totalSize > 0 ? Math.round((conversationSize / totalSize) * 100) : 0,
        currentAttachmentsPercentage: totalSize > 0 ? Math.round((currentAttachmentsSize / totalSize) * 100) : 0,
    };
};

// Get context usage percentage using total context
export const getTotalContextUsagePercentage = (messageChain: Message[], currentAttachments: Attachment[]): number => {
    const totalTokens = calculateTotalContextSize(messageChain, currentAttachments);
    return Math.min(100, Math.round((totalTokens / CONTEXT_LIMITS.MAX_CONTEXT) * 100));
};

// Get context size warning level using total context
export const getTotalContextSizeWarning = (
    messageChain: Message[],
    currentAttachments: Attachment[]
): 'none' | 'warning' | 'danger' | 'critical' => {
    const totalTokens = calculateTotalContextSize(messageChain, currentAttachments);
    return getContextSizeWarning(totalTokens);
};
