import type { MessageMap } from '../redux/slices/core/messages';
import type { Attachment, Message } from '../types';
import { getApproximateTokenCount } from './tokenizer';

export const calculateContextSize = (messageMap: MessageMap): number => {
    // Use fast approximation for better performance (4 chars/token)
    return Object.values(messageMap).reduce((total, message) => {
        const contentTokens = getApproximateTokenCount(message.content || '');
        const toolCallTokens = getApproximateTokenCount(message.toolCall || '');
        const toolResultTokens = getApproximateTokenCount(message.toolResult || '');
        const contextTokens = getApproximateTokenCount(message.context || '');

        return total + contentTokens + toolCallTokens + toolResultTokens + contextTokens;
    }, 0);
};

/**
 * Calculate tokens from message content only (excluding context)
 * Used for UI components that need to show message content tokens separately
 */
export const calculateMessageContentTokens = (messageChain: Message[]): number => {
    return messageChain.reduce((total, message) => {
        const contentTokens = getApproximateTokenCount(message.content || '');
        const toolCallTokens = getApproximateTokenCount(message.toolCall || '');
        const toolResultTokens = getApproximateTokenCount(message.toolResult || '');
        return total + contentTokens + toolCallTokens + toolResultTokens;
    }, 0);
};

// Calculate estimated token size for a single attachment
export const calculateSingleAttachmentContextSize = (attachment: Attachment): number => {
    if (!attachment || attachment.processing || !attachment.markdown || !attachment.filename) {
        return 0;
    }

    // Use cached token count if available (for performance)
    if (attachment.tokenCount !== undefined && attachment.tokenCount > 0) {
        return attachment.tokenCount;
    }

    try {
        // Calculate the context that would be generated by flattenAttachmentsForLlm for this file
        const filename = `Filename: ${attachment.filename}`;
        const header = 'File contents:';
        const beginMarker = '----- BEGIN FILE CONTENTS -----';
        const endMarker = '----- END FILE CONTENTS -----';
        const content = attachment.markdown.trim();

        const fullContext = [filename, header, beginMarker, content, endMarker].join('\n');

        // Use fast approximation for better performance (4 chars/token)
        return getApproximateTokenCount(fullContext);
    } catch (error) {
        console.warn('Error calculating attachment context size:', error, attachment);
        return 0;
    }
};

/**
 * Calculate estimated token size for attachments based on their markdown content.
 * This function simulates the token cost of what would be sent to the LLM.
 *
 * @param attachments Array of attachments to calculate context size for
 * @returns Total estimated token count for all attachments
 */
export const calculateAttachmentContextSize = (attachments: Attachment[]): number => {
    return attachments.reduce((total, attachment) => {
        return total + calculateSingleAttachmentContextSize(attachment);
    }, 0);
};

// Context window limits (approximate)
export const CONTEXT_LIMITS = {
    WARNING_THRESHOLD: 90000, // Start warning at ~24K tokens
    DANGER_THRESHOLD: 100000, // Strong warning at ~48K tokens
    MAX_CONTEXT: 128000, // Typical context window limit
} as const;

export const getContextSizeWarning = (tokenCount: number): 'none' | 'warning' | 'danger' | 'critical' => {
    if (tokenCount >= CONTEXT_LIMITS.MAX_CONTEXT) {
        return 'critical';
    } else if (tokenCount >= CONTEXT_LIMITS.DANGER_THRESHOLD) {
        return 'danger';
    } else if (tokenCount >= CONTEXT_LIMITS.WARNING_THRESHOLD) {
        return 'warning';
    }
    return 'none';
};

export const formatTokenCount = (tokenCount: number): string => {
    if (tokenCount < 1000) {
        return `${Math.round(tokenCount)} tokens`;
    } else {
        return `${(tokenCount / 1000).toFixed(1)}K tokens`;
    }
};

// Get size level for individual files
export const getFileSizeLevel = (tokenCount: number): 'small' | 'medium' | 'large' | 'very-large' => {
    if (tokenCount >= 20000) {
        // Very large single file
        return 'very-large';
    } else if (tokenCount >= 10000) {
        // Large single file
        return 'large';
    } else if (tokenCount >= 5000) {
        // Medium single file
        return 'medium';
    }
    return 'small';
};

// Get context usage percentage (0-100)
export const getContextUsagePercentage = (tokenCount: number): number => {
    return Math.min(100, Math.round((tokenCount / CONTEXT_LIMITS.MAX_CONTEXT) * 100));
};

// Get progress bar state for visual indicators
export const getContextProgressState = (percentage: number): 'low' | 'medium' | 'high' | 'critical' => {
    if (percentage >= 100) {
        return 'critical';
    } else if (percentage >= 75) {
        return 'high';
    } else if (percentage >= 50) {
        return 'medium';
    }
    return 'low';
};

// Calculate total context size including conversation history and current attachments
export const calculateTotalContextSize = (messageChain: Message[], currentAttachments: Attachment[]): number => {
    const conversationContext = calculateConversationContextSize(messageChain);
    const currentAttachmentsContext = calculateAttachmentContextSize(currentAttachments);
    return conversationContext + currentAttachmentsContext;
};

// Calculate context size for the conversation history (messages + their attachments)
export const calculateConversationContextSize = (messageChain: Message[]): number => {
    return messageChain.reduce((total, message) => {
        // Message content, tool calls, and tool results (using fast approximation)
        const contentTokens = getApproximateTokenCount(message.content || '');
        const toolCallTokens = getApproximateTokenCount(message.toolCall || '');
        const toolResultTokens = getApproximateTokenCount(message.toolResult || '');

        // Context from attachments in this message (already formatted by flattenAttachmentsForLlm)
        const contextTokens = getApproximateTokenCount(message.context || '');

        return total + contentTokens + toolCallTokens + toolResultTokens + contextTokens;
    }, 0);
};

// Get context breakdown for display
export const getContextBreakdown = (messageChain: Message[], currentAttachments: Attachment[]) => {
    const conversationSize = calculateConversationContextSize(messageChain);
    const currentAttachmentsSize = calculateAttachmentContextSize(currentAttachments);
    const totalSize = conversationSize + currentAttachmentsSize;

    return {
        conversationSize,
        currentAttachmentsSize,
        totalSize,
        conversationPercentage: totalSize > 0 ? Math.round((conversationSize / totalSize) * 100) : 0,
        currentAttachmentsPercentage: totalSize > 0 ? Math.round((currentAttachmentsSize / totalSize) * 100) : 0,
    };
};

// Get context usage percentage using total context
export const getTotalContextUsagePercentage = (messageChain: Message[], currentAttachments: Attachment[]): number => {
    const totalTokens = calculateTotalContextSize(messageChain, currentAttachments);
    return Math.min(100, Math.round((totalTokens / CONTEXT_LIMITS.MAX_CONTEXT) * 100));
};

// Get context size warning level using total context
export const getTotalContextSizeWarning = (
    messageChain: Message[],
    currentAttachments: Attachment[]
): 'none' | 'warning' | 'danger' | 'critical' => {
    const totalTokens = calculateTotalContextSize(messageChain, currentAttachments);
    return getContextSizeWarning(totalTokens);
};

// Remove a specific file from a message's context (used for filtering at LLM call time)
export const removeFileFromMessageContext = (message: Message, filename: string): Message => {
    if (!message.context) return message;

    const lines = message.context.split('\n');
    const newLines: string[] = [];

    let currentFilename = '';
    let skipFile = false;
    let isInFileContent = false;

    for (const line of lines) {
        if (line.startsWith('Filename: ')) {
            currentFilename = line.substring('Filename: '.length);
            skipFile = currentFilename === filename;

            if (!skipFile) {
                newLines.push(line);
            }
        } else if (line === '----- BEGIN FILE CONTENTS -----') {
            isInFileContent = true;
            if (!skipFile) {
                newLines.push(line);
            }
        } else if (line === '----- END FILE CONTENTS -----') {
            isInFileContent = false;
            if (!skipFile) {
                newLines.push(line);
            }
            currentFilename = '';
        } else if (isInFileContent || line.startsWith('File contents:')) {
            if (!skipFile) {
                newLines.push(line);
            }
        } else {
            newLines.push(line);
        }
    }

    return {
        ...message,
        context: newLines.join('\n'),
    };
};
