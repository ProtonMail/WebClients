import { convertZonedDateTimeToUTC, fromUTCDate, toUTCDate } from '../../date/timezone';
import { VcalVeventComponent } from '../../interfaces/calendar';
import { propertyToUTCDate } from '../vcalConverter';
import { getPropertyTzid } from '../vcalHelper';
import {getIsAllDay} from '../veventHelper';
import { RecurringResult, getOccurrences, getOccurrencesBetween } from './recurring';
import { getIsRruleEqual } from './rruleEqual';

export const getAreOccurrencesSubset = (
    newOccurrences: (RecurringResult | Pick<RecurringResult, 'localStart'>)[],
    oldVevent: VcalVeventComponent
) => {
    const cache = {};
    for (const { localStart } of newOccurrences) {
        const isAllDay = getIsAllDay(oldVevent);
        const startTzid = getPropertyTzid(oldVevent.dtstart);
        let utcStart = localStart;
        if (!isAllDay && startTzid) {
            utcStart = toUTCDate(convertZonedDateTimeToUTC(fromUTCDate(localStart), startTzid));
        }
        const [oldOccurrence] = getOccurrencesBetween(oldVevent, +utcStart, +utcStart, cache);
        if (!oldOccurrence) {
            return false;
        }
    }
    return true;
};

/**
 * Return true if the set of occurrences of the new rrule is contained (equality counts) in the old rrule.
 * Return false otherwise
 * We restrict to rrules that can be created by us
 */
export const getIsRruleSubset = (newVevent: VcalVeventComponent, oldVevent: VcalVeventComponent) => {
    const [{ rrule: newRrule, dtstart: newDtstart }, { rrule: oldRrule }] = [newVevent, oldVevent];
    const isRruleEqual = getIsRruleEqual(newRrule, oldRrule);
    if (!newRrule || !oldRrule || isRruleEqual) {
        return isRruleEqual;
    }
    const { count: oldCount, until: oldUntil } = oldRrule.value;
    const { count: newCount, until: newUntil } = newRrule.value;
    if (!newCount && !newUntil && (oldCount || oldUntil)) {
        return false;
    }
    /**
     *  Given the repeating nature of recurring rules, we're gonna play dirty here
     *  and simply check if the at max 10 first occurrences of the new recurring rule are generated by the old one.
     *  For the recurring rules we support this is more than enough, but it wouldn't be
     *  in a more general (and pathological) scenario.
     *  The alternative would be to write some code checking the frequency, interval,
     *  byday, etc properties and going case by case. That code would be cumbersome and ugly
     */
    // either newUntil or newCount are not undefined, so we can check if all new occurrences are in the original set
    // but for performance we use the same trick as above and check max 10
    const maxCount = newCount ? Math.min(newCount, 10) : 10;
    const newOccurrences = newUntil
        ? getOccurrencesBetween(newVevent, +propertyToUTCDate(newDtstart), +toUTCDate(newUntil)).slice(0, 10)
        : getOccurrences({ component: newVevent, maxCount });

    return getAreOccurrencesSubset(newOccurrences, oldVevent);
};
