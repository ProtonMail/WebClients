import { sub } from 'date-fns';

import { serverTime } from '@proton/crypto';
import { PROTON_DOMAINS } from '@proton/shared/lib/constants';
import { captureMessage } from '@proton/shared/lib/helpers/sentry';

import { EXPECTED_EPOCH_INTERVAL, KT_DOMAINS, MAX_EPOCH_INTERVAL } from '../constants/constants';

/**
 * Retrieve when an obsolescence token was generated by parsing
 * from the token itself
 */
export const getTimeFromObsolescenceToken = (ObsolescenceToken: string) => parseInt(ObsolescenceToken.slice(0, 16), 16);

/**
 * Extract the domain from an email address
 */
export const getEmailDomain = (email: string) => `@${email.split('@')[1]}`;

/**
 * Check whether a timestamp is older than maximum epoch interval from the given reference
 */
export const isTimestampTooOlderThanReference = (time: number, referenceTime: number) =>
    referenceTime > MAX_EPOCH_INTERVAL + time;

/**
 * Check whether a timestamp is older than maximum epoch interval from now
 */
export const isTimestampTooOld = (time: number) => isTimestampTooOlderThanReference(time, +serverTime());

/**
 * Check whether a timestamp is within a maximum epoch interval range
 * from the given temporal reference, boundaries included
 */
export const isTimestampWithinSingleRange = (time: number, referenceTime: number) =>
    Math.abs(referenceTime - time) <= MAX_EPOCH_INTERVAL;

/**
 * Check whether a timestamp is within two limits, boundaries included
 */
export const isTimestampWithinDoubleRange = (time: number, start: number, end: number) => time >= start && time <= end;

/**
 * Check whether a timestamp is within a maximum epoch interval range from
 * 90 days in the past, which is the threshold after which epoch certificates
 * expire
 */
export const isTimestampOldEnough = (time: number) =>
    isTimestampWithinSingleRange(time, +sub(serverTime(), { days: 90 }));

/**
 * Check whether a timestamp is older than 90 days in the past,
 * which is the threshold after which epoch certificates expire
 */
export const isTimestampOlderThanThreshold = (time: number) => time < +sub(serverTime(), { days: 90 });

/**
 * Helper to send KT-related sentry reports
 */
export const ktSentryReport = (errorMessage: string, extra?: { [key: string]: any }) =>
    captureMessage(`[KeyTransparency] ${errorMessage}`, { extra });

/**
 * Helper to send KT-related sentry reports
 */
export const ktSentryReportError = (error: any, extra?: { [key: string]: any }) => {
    const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : 'unknown error';
    const stack = error instanceof Error ? error.stack : undefined;
    ktSentryReport(errorMessage, { ...extra, stack });
};

export class KeyTransparencyError extends Error {}

export const throwKTError = (errorMessage: string, extra?: { [key: string]: any }): never => {
    ktSentryReport(errorMessage, extra);
    throw new KeyTransparencyError(errorMessage);
};

/**
 * Derive which base domain is being used, whether production or test
 */
export const getBaseDomain = (sendReport: boolean = true) => {
    // The app name is removed
    const { hostname } = window.location;
    const currentDomain = hostname.slice(hostname.indexOf('.') + 1);

    // Production domain, e.g. protonmail.com -> PROD
    if (PROTON_DOMAINS.includes(currentDomain)) {
        return KT_DOMAINS.PROD;
    }

    // Dev env, i.e. proton.black -> ATLAS_DEV
    if (currentDomain === 'proton.black') {
        return KT_DOMAINS.ATLAS_DEV;
    }

    const domainParts = currentDomain.split('.');

    // Atlas env over production, i.e. {env}.proton.pink -> PROD
    if (domainParts[domainParts.length - 2] === 'proton' && domainParts[domainParts.length - 1] === 'pink') {
        return KT_DOMAINS.PROD;
    }

    // Any other domain (including atlas env over dev, i.e. {env}.proton.black) -> no certificates are released.
    // Since this function is also used to test whether to use KT at all, we don't want to spam sentry with
    // attempts to figure this out, in which case sendReport should be false
    if (sendReport) {
        return throwKTError('Domain not recognised', {
            hostname,
            currentDomain,
            domainParts: JSON.stringify(domainParts),
        });
    }

    return KT_DOMAINS.UNKNOWN;
};

export const getSelfAuditInterval = () => {
    return EXPECTED_EPOCH_INTERVAL;
}