import fs from 'fs/promises';
import path from 'path';
import * as prettier from 'prettier';
import readline from 'readline';
import ts from 'typescript';

type MetricType = 'Counter' | 'Histogram';

interface ParsedFile {
    importName: string;
    interfaceName: string;
    type: MetricType;
    propName: string;
    metricName: string;
    version: number;
}

async function findFirstInterfaceName(fileName: string) {
    const sourceCode = await fs.readFile(fileName, 'utf-8');
    const sourceFile = ts.createSourceFile(fileName, sourceCode, ts.ScriptTarget.ES2021, true);

    function visit(node: ts.Node): any {
        if (ts.isInterfaceDeclaration(node)) {
            const foundInterfaceName = node.name && node.name.text;
            return foundInterfaceName;
        }

        return ts.forEachChild(node, visit);
    }

    return visit(sourceFile);
}

const typesDirectoryPath = './types';

function getImportName(fileName: string) {
    return fileName.replace(/\.d\.ts$/, '');
}

function getType(fileName: string): MetricType {
    const isCounterRegex = /.*total_v\d.schema.d.ts$/;
    const isCounter = isCounterRegex.test(fileName);

    if (isCounter) {
        return 'Counter';
    }

    return 'Histogram';
}

function getPropName(fileName: string) {
    return fileName.replace(/^web_/, '').replace(/_v\d.schema.d.ts/, '');
}

function getMetricName(fileName: string) {
    return fileName.replace(/_v\d.schema.d.ts/, '');
}

function getVersion(fileName: string): number {
    const regex = /_v(\d+)\.schema\.d\.ts/;
    const match = fileName.match(regex);

    if (!match) {
        return NaN;
    }

    return parseInt(match[1]);
}

function getVersionInMetricsClassByName(metricsClass: string, metricName: string) {
    const existingVersionMatch = metricsClass.match(new RegExp(`${metricName}.*version: (\\d+)`));
    const existingVersion = existingVersionMatch ? parseInt(existingVersionMatch[1], 10) : 0;
    return existingVersion;
}

async function handleFile(fileName: string) {
    const importName = getImportName(fileName);
    const interfaceName = await findFirstInterfaceName(path.join(typesDirectoryPath, fileName));
    const type = getType(fileName);
    const propName = getPropName(fileName);
    const metricName = getMetricName(fileName);
    const version = getVersion(fileName);

    const parsedFile: ParsedFile = {
        importName,
        interfaceName,
        type,
        propName,
        metricName,
        version,
    };

    return parsedFile;
}

async function generateCode(parsedFiles: ParsedFile[]) {
    let includeCounterImport = false;
    let includeHistogramImport = false;

    let code = `
import MetricsBase from './lib/MetricsBase';
import type IMetricsRequestService from './lib/types/IMetricsRequestService';
    `;

    const addImport = (interfaceName: string, importName: string) => {
        code += `
import type { ${interfaceName} } from '${typesDirectoryPath}/${importName}'; 
        `;
    };

    parsedFiles.forEach((file) => {
        addImport(file.interfaceName, file.importName);
    });

    code += `
class Metrics extends MetricsBase {
    `;

    const addProperty = ({ propName, type, interfaceName }: ParsedFile) => {
        if (!includeCounterImport && type === 'Counter') {
            includeCounterImport = true;
        } else if (!includeHistogramImport && type === 'Histogram') {
            includeHistogramImport = true;
        }

        code += `
    public ${propName}: ${type}<${interfaceName}>;
    `;
    };

    parsedFiles.forEach((file) => {
        addProperty(file);
    });

    code += `
    constructor(requestService: IMetricsRequestService) {
        super(requestService);
    `;

    const initProperty = ({ propName, type, interfaceName, metricName, version }: ParsedFile) => {
        code += `
    this.${propName} = new ${type}<${interfaceName}>({ name: '${metricName}', version: ${version} }, this.requestService);
    `;
    };

    parsedFiles.forEach((file) => {
        initProperty(file);
    });

    code += `
    }
}

export default Metrics;
`;

    if (includeCounterImport) {
        code =
            `
import Counter from './lib/Counter';
    ` + code;
    }

    if (includeHistogramImport) {
        code =
            `
import Histogram from './lib/Histogram';
    ` + code;
    }

    code =
        `
/**
 * THIS CODE IS AUTOGENERATED
 * using \`yarn workspace @proton/metrics generate-metrics\`
 * 
 * For more information please consult the documentation
 * https://confluence.protontech.ch/pages/viewpage.action?pageId=121927830
 */

` + code;

    const options = await prettier.resolveConfig(path.join('..', '..', 'prettier.config.mjs'));
    return prettier.format(code, { ...options, parser: 'typescript' });
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

const promptUser = (question: string): Promise<string> => {
    return new Promise((resolve) => {
        rl.question(question, resolve);
    });
};

async function main() {
    const existingMetricsContent = await fs.readFile('./Metrics.ts', 'utf-8');

    const files = await fs.readdir(typesDirectoryPath);

    const tsFiles = files.filter((fileName) => fileName.endsWith('.ts'));

    const parsedFiles = await Promise.all(tsFiles.map((file) => handleFile(file)));

    const dedupedFiles: { [metricName: string]: ParsedFile } = {};

    for (const file of parsedFiles) {
        const existingVersion = getVersionInMetricsClassByName(existingMetricsContent, file.metricName);

        const futureVersion = dedupedFiles[file.metricName];
        if (futureVersion && futureVersion.version >= file.version) {
            continue;
        }

        if (existingVersion !== 0 && file.version > existingVersion) {
            const answer = await promptUser(
                `Metric "${file.metricName}" already exists with version ${existingVersion}. ` +
                    `Do you want to replace it with version ${file.version}? (y/n): `
            );
            if (answer.toLowerCase().includes('y')) {
                console.log(
                    `\x1b[1m\x1b[31mConsider deleting the version ${existingVersion} of ${file.metricName} when possible. See documentation here: https://confluence.protontech.ch/pages/viewpage.action?pageId=121927830#id-@proton/metrics-Deletinganexistingmetric\x1b[0m`
                );
                dedupedFiles[file.metricName] = file;
            }
        } else {
            dedupedFiles[file.metricName] = file;
        }
    }

    rl.close();

    const code = await generateCode(Object.values(dedupedFiles));

    await fs.writeFile('./Metrics.ts', code);
}

void main();
