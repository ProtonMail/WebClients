import fs from 'fs/promises';
import path from 'path';
import * as prettier from 'prettier';
import ts from 'typescript';

type MetricType = 'Counter' | 'Histogram';

interface ParsedFile {
    importName: string;
    interfaceName: string;
    type: MetricType;
    propName: string;
    metricName: string;
    version: string;
}

async function findFirstInterfaceName(fileName: string) {
    const sourceCode = await fs.readFile(fileName, 'utf-8');
    const sourceFile = ts.createSourceFile(fileName, sourceCode, ts.ScriptTarget.ES2021, true);

    function visit(node: ts.Node): any {
        if (ts.isInterfaceDeclaration(node)) {
            const foundInterfaceName = node.name && node.name.text;
            return foundInterfaceName;
        }

        return ts.forEachChild(node, visit);
    }

    return visit(sourceFile);
}

const typesDirectoryPath = './types';

function getImportName(fileName: string) {
    return fileName.replace(/\.d\.ts$/, '');
}

function getType(fileName: string): MetricType {
    const isCounterRegex = /.*total_v\d.schema.d.ts$/;
    const isCounter = isCounterRegex.test(fileName);

    if (isCounter) {
        return 'Counter';
    }

    return 'Histogram';
}

function getPropName(fileName: string) {
    return fileName.replace(/^web_/, '').replace(/_v\d.schema.d.ts/, '');
}

function getMetricName(fileName: string) {
    return fileName.replace(/_v\d.schema.d.ts/, '');
}

function getVersion(fileName: string) {
    const regex = /_v(\d+)\.schema\.d\.ts/;
    const match = fileName.match(regex);

    if (!match) {
        return '';
    }

    return match[1];
}

async function handleFile(fileName: string) {
    const importName = getImportName(fileName);
    const interfaceName = await findFirstInterfaceName(path.join(typesDirectoryPath, fileName));
    const type = getType(fileName);
    const propName = getPropName(fileName);
    const metricName = getMetricName(fileName);
    const version = getVersion(fileName);

    const parsedFile: ParsedFile = {
        importName,
        interfaceName,
        type,
        propName,
        metricName,
        version,
    };

    return parsedFile;
}

async function generateCode(parsedFiles: ParsedFile[]) {
    let includeCounterImport = false;
    let includeHistogramImport = false;

    let code = `
import MetricsBase from './lib/MetricsBase';
import IMetricsRequestService from './lib/types/IMetricsRequestService';
    `;

    const addImport = (interfaceName: string, importName: string) => {
        code += `
import { ${interfaceName} } from '${typesDirectoryPath}/${importName}'; 
        `;
    };

    parsedFiles.forEach((file) => {
        addImport(file.interfaceName, file.importName);
    });

    code += `
class Metrics extends MetricsBase {
    `;

    const addProperty = ({ propName, type, interfaceName }: ParsedFile) => {
        if (!includeCounterImport && type === 'Counter') {
            includeCounterImport = true;
        } else if (!includeHistogramImport && type === 'Histogram') {
            includeHistogramImport = true;
        }

        code += `
    public ${propName}: ${type}<${interfaceName}>;
    `;
    };

    parsedFiles.forEach((file) => {
        addProperty(file);
    });

    code += `
    constructor(requestService: IMetricsRequestService) {
        super(requestService);
    `;

    const initProperty = ({ propName, type, interfaceName, metricName, version }: ParsedFile) => {
        code += `
    this.${propName} = new ${type}<${interfaceName}>({ name: '${metricName}', version: ${version} }, this.requestService);
    `;
    };

    parsedFiles.forEach((file) => {
        initProperty(file);
    });

    code += `
    }
}

export default Metrics;
`;

    if (includeCounterImport) {
        code =
            `
import Counter from './lib/Counter';
    ` + code;
    }

    if (includeHistogramImport) {
        code =
            `
import Histogram from './lib/Histogram';
    ` + code;
    }

    code =
        `
/**
 * THIS CODE IS AUTOGENERATED
 * using \`yarn workspace @proton/metrics generate-metrics\`
 * 
 * For more information please consult the documentation
 * https://confluence.protontech.ch/pages/viewpage.action?pageId=121927830
 */

` + code;

    const options = await prettier.resolveConfig(path.join('..', '..', 'prettier.config.mjs'));
    return prettier.format(code, { ...options, parser: 'typescript' });
}

async function main() {
    const files = await fs.readdir(typesDirectoryPath);

    const tsFiles = files.filter((fileName) => fileName.endsWith('.ts'));

    const parsedFiles = await Promise.all(tsFiles.map((file) => handleFile(file)));

    let dedupedFiles: { [interfaceName: string]: ParsedFile } = {};

    parsedFiles.forEach((file) => {
        const existingVersion = dedupedFiles[file.interfaceName];

        if (existingVersion && existingVersion.version >= file.version) {
            return;
        }

        dedupedFiles[file.interfaceName] = file;
    });

    const code = await generateCode(Object.values(dedupedFiles));

    await fs.writeFile('./Metrics.ts', code);
}

void main();
