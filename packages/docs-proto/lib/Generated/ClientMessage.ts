/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: ClientMessage.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from './DocumentUpdate'
import * as dependency_2 from './Event'
import * as pb_1 from 'google-protobuf'
export class ClientMessage extends pb_1.Message {
  #one_of_decls: number[][] = [[2, 3]]
  constructor(
    data?:
      | any[]
      | ({} & (
          | {
              documentUpdatesMessage?: ClientMessageWithDocumentUpdates
              eventsMessage?: never
            }
          | {
              documentUpdatesMessage?: never
              eventsMessage?: ClientMessageWithEvents
            }
        )),
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('documentUpdatesMessage' in data && data.documentUpdatesMessage != undefined) {
        this.documentUpdatesMessage = data.documentUpdatesMessage
      }
      if ('eventsMessage' in data && data.eventsMessage != undefined) {
        this.eventsMessage = data.eventsMessage
      }
    }
  }
  get documentUpdatesMessage() {
    return pb_1.Message.getWrapperField(this, ClientMessageWithDocumentUpdates, 2) as ClientMessageWithDocumentUpdates
  }
  set documentUpdatesMessage(value: ClientMessageWithDocumentUpdates) {
    pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value)
  }
  get has_documentUpdatesMessage() {
    return pb_1.Message.getField(this, 2) != null
  }
  get eventsMessage() {
    return pb_1.Message.getWrapperField(this, ClientMessageWithEvents, 3) as ClientMessageWithEvents
  }
  set eventsMessage(value: ClientMessageWithEvents) {
    pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value)
  }
  get has_eventsMessage() {
    return pb_1.Message.getField(this, 3) != null
  }
  get message() {
    const cases: {
      [index: number]: 'none' | 'documentUpdatesMessage' | 'eventsMessage'
    } = {
      0: 'none',
      2: 'documentUpdatesMessage',
      3: 'eventsMessage',
    }
    return cases[pb_1.Message.computeOneofCase(this, [2, 3])]
  }
  static fromObject(data: {
    documentUpdatesMessage?: ReturnType<typeof ClientMessageWithDocumentUpdates.prototype.toObject>
    eventsMessage?: ReturnType<typeof ClientMessageWithEvents.prototype.toObject>
  }): ClientMessage {
    const message = new ClientMessage({})
    if (data.documentUpdatesMessage != null) {
      message.documentUpdatesMessage = ClientMessageWithDocumentUpdates.fromObject(data.documentUpdatesMessage)
    }
    if (data.eventsMessage != null) {
      message.eventsMessage = ClientMessageWithEvents.fromObject(data.eventsMessage)
    }
    return message
  }
  toObject() {
    const data: {
      documentUpdatesMessage?: ReturnType<typeof ClientMessageWithDocumentUpdates.prototype.toObject>
      eventsMessage?: ReturnType<typeof ClientMessageWithEvents.prototype.toObject>
    } = {}
    if (this.documentUpdatesMessage != null) {
      data.documentUpdatesMessage = this.documentUpdatesMessage.toObject()
    }
    if (this.eventsMessage != null) {
      data.eventsMessage = this.eventsMessage.toObject()
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.has_documentUpdatesMessage)
      writer.writeMessage(2, this.documentUpdatesMessage, () => this.documentUpdatesMessage.serialize(writer))
    if (this.has_eventsMessage) writer.writeMessage(3, this.eventsMessage, () => this.eventsMessage.serialize(writer))
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientMessage {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ClientMessage()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 2:
          reader.readMessage(
            message.documentUpdatesMessage,
            () => (message.documentUpdatesMessage = ClientMessageWithDocumentUpdates.deserialize(reader)),
          )
          break
        case 3:
          reader.readMessage(
            message.eventsMessage,
            () => (message.eventsMessage = ClientMessageWithEvents.deserialize(reader)),
          )
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): ClientMessage {
    return ClientMessage.deserialize(bytes)
  }
}
export class ClientMessageWithDocumentUpdates extends pb_1.Message {
  #one_of_decls: number[][] = []
  constructor(
    data?:
      | any[]
      | {
          updates?: dependency_1.DocumentUpdateArray
        },
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('updates' in data && data.updates != undefined) {
        this.updates = data.updates
      }
    }
  }
  get updates() {
    return pb_1.Message.getWrapperField(this, dependency_1.DocumentUpdateArray, 2) as dependency_1.DocumentUpdateArray
  }
  set updates(value: dependency_1.DocumentUpdateArray) {
    pb_1.Message.setWrapperField(this, 2, value)
  }
  get has_updates() {
    return pb_1.Message.getField(this, 2) != null
  }
  static fromObject(data: {
    updates?: ReturnType<typeof dependency_1.DocumentUpdateArray.prototype.toObject>
  }): ClientMessageWithDocumentUpdates {
    const message = new ClientMessageWithDocumentUpdates({})
    if (data.updates != null) {
      message.updates = dependency_1.DocumentUpdateArray.fromObject(data.updates)
    }
    return message
  }
  toObject() {
    const data: {
      updates?: ReturnType<typeof dependency_1.DocumentUpdateArray.prototype.toObject>
    } = {}
    if (this.updates != null) {
      data.updates = this.updates.toObject()
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.has_updates) writer.writeMessage(2, this.updates, () => this.updates.serialize(writer))
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientMessageWithDocumentUpdates {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ClientMessageWithDocumentUpdates()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 2:
          reader.readMessage(
            message.updates,
            () => (message.updates = dependency_1.DocumentUpdateArray.deserialize(reader)),
          )
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): ClientMessageWithDocumentUpdates {
    return ClientMessageWithDocumentUpdates.deserialize(bytes)
  }
}
export class ClientMessageWithEvents extends pb_1.Message {
  #one_of_decls: number[][] = []
  constructor(
    data?:
      | any[]
      | {
          events?: dependency_2.Event[]
        },
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('events' in data && data.events != undefined) {
        this.events = data.events
      }
    }
  }
  get events() {
    return pb_1.Message.getRepeatedWrapperField(this, dependency_2.Event, 1) as dependency_2.Event[]
  }
  set events(value: dependency_2.Event[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value)
  }
  static fromObject(data: {
    events?: ReturnType<typeof dependency_2.Event.prototype.toObject>[]
  }): ClientMessageWithEvents {
    const message = new ClientMessageWithEvents({})
    if (data.events != null) {
      message.events = data.events.map((item) => dependency_2.Event.fromObject(item))
    }
    return message
  }
  toObject() {
    const data: {
      events?: ReturnType<typeof dependency_2.Event.prototype.toObject>[]
    } = {}
    if (this.events != null) {
      data.events = this.events.map((item: dependency_2.Event) => item.toObject())
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.events.length)
      writer.writeRepeatedMessage(1, this.events, (item: dependency_2.Event) => item.serialize(writer))
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClientMessageWithEvents {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ClientMessageWithEvents()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.events, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              1,
              dependency_2.Event.deserialize(reader),
              dependency_2.Event,
            ),
          )
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): ClientMessageWithEvents {
    return ClientMessageWithEvents.deserialize(bytes)
  }
}
