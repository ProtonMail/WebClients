/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: DocumentUpdate.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf'
export class DocumentUpdate extends pb_1.Message {
  #one_of_decls: number[][] = []
  constructor(
    data?:
      | any[]
      | {
          encryptedContent?: Uint8Array
          version?: number
          timestamp?: number
          authorId?: string
        },
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('encryptedContent' in data && data.encryptedContent != undefined) {
        this.encryptedContent = data.encryptedContent
      }
      if ('version' in data && data.version != undefined) {
        this.version = data.version
      }
      if ('timestamp' in data && data.timestamp != undefined) {
        this.timestamp = data.timestamp
      }
      if ('authorId' in data && data.authorId != undefined) {
        this.authorId = data.authorId
      }
    }
  }
  get encryptedContent() {
    return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array
  }
  set encryptedContent(value: Uint8Array) {
    pb_1.Message.setField(this, 1, value)
  }
  get version() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number
  }
  set version(value: number) {
    pb_1.Message.setField(this, 2, value)
  }
  get timestamp() {
    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number
  }
  set timestamp(value: number) {
    pb_1.Message.setField(this, 3, value)
  }
  get authorId() {
    return pb_1.Message.getFieldWithDefault(this, 4, '') as string
  }
  set authorId(value: string) {
    pb_1.Message.setField(this, 4, value)
  }
  static fromObject(data: {
    encryptedContent?: Uint8Array
    version?: number
    timestamp?: number
    authorId?: string
  }): DocumentUpdate {
    const message = new DocumentUpdate({})
    if (data.encryptedContent != null) {
      message.encryptedContent = data.encryptedContent
    }
    if (data.version != null) {
      message.version = data.version
    }
    if (data.timestamp != null) {
      message.timestamp = data.timestamp
    }
    if (data.authorId != null) {
      message.authorId = data.authorId
    }
    return message
  }
  toObject() {
    const data: {
      encryptedContent?: Uint8Array
      version?: number
      timestamp?: number
      authorId?: string
    } = {}
    if (this.encryptedContent != null) {
      data.encryptedContent = this.encryptedContent
    }
    if (this.version != null) {
      data.version = this.version
    }
    if (this.timestamp != null) {
      data.timestamp = this.timestamp
    }
    if (this.authorId != null) {
      data.authorId = this.authorId
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.encryptedContent.length) writer.writeBytes(1, this.encryptedContent)
    if (this.version != 0) writer.writeInt32(2, this.version)
    if (this.timestamp != 0) writer.writeUint64(3, this.timestamp)
    if (this.authorId.length) writer.writeString(4, this.authorId)
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DocumentUpdate {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new DocumentUpdate()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 1:
          message.encryptedContent = reader.readBytes()
          break
        case 2:
          message.version = reader.readInt32()
          break
        case 3:
          message.timestamp = reader.readUint64()
          break
        case 4:
          message.authorId = reader.readString()
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): DocumentUpdate {
    return DocumentUpdate.deserialize(bytes)
  }
}
export class SignedPlaintextContent extends pb_1.Message {
  #one_of_decls: number[][] = []
  constructor(
    data?:
      | any[]
      | {
          content?: Uint8Array
          signature?: Uint8Array
        },
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('content' in data && data.content != undefined) {
        this.content = data.content
      }
      if ('signature' in data && data.signature != undefined) {
        this.signature = data.signature
      }
    }
  }
  get content() {
    return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array
  }
  set content(value: Uint8Array) {
    pb_1.Message.setField(this, 1, value)
  }
  get signature() {
    return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array
  }
  set signature(value: Uint8Array) {
    pb_1.Message.setField(this, 2, value)
  }
  static fromObject(data: { content?: Uint8Array; signature?: Uint8Array }): SignedPlaintextContent {
    const message = new SignedPlaintextContent({})
    if (data.content != null) {
      message.content = data.content
    }
    if (data.signature != null) {
      message.signature = data.signature
    }
    return message
  }
  toObject() {
    const data: {
      content?: Uint8Array
      signature?: Uint8Array
    } = {}
    if (this.content != null) {
      data.content = this.content
    }
    if (this.signature != null) {
      data.signature = this.signature
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.content.length) writer.writeBytes(1, this.content)
    if (this.signature.length) writer.writeBytes(2, this.signature)
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignedPlaintextContent {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SignedPlaintextContent()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 1:
          message.content = reader.readBytes()
          break
        case 2:
          message.signature = reader.readBytes()
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): SignedPlaintextContent {
    return SignedPlaintextContent.deserialize(bytes)
  }
}
export class DocumentUpdateArray extends pb_1.Message {
  #one_of_decls: number[][] = []
  constructor(
    data?:
      | any[]
      | {
          documentUpdates?: DocumentUpdate[]
        },
  ) {
    super()
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls)
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('documentUpdates' in data && data.documentUpdates != undefined) {
        this.documentUpdates = data.documentUpdates
      }
    }
  }
  get documentUpdates() {
    return pb_1.Message.getRepeatedWrapperField(this, DocumentUpdate, 1) as DocumentUpdate[]
  }
  set documentUpdates(value: DocumentUpdate[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value)
  }
  static fromObject(data: {
    documentUpdates?: ReturnType<typeof DocumentUpdate.prototype.toObject>[]
  }): DocumentUpdateArray {
    const message = new DocumentUpdateArray({})
    if (data.documentUpdates != null) {
      message.documentUpdates = data.documentUpdates.map((item) => DocumentUpdate.fromObject(item))
    }
    return message
  }
  toObject() {
    const data: {
      documentUpdates?: ReturnType<typeof DocumentUpdate.prototype.toObject>[]
    } = {}
    if (this.documentUpdates != null) {
      data.documentUpdates = this.documentUpdates.map((item: DocumentUpdate) => item.toObject())
    }
    return data
  }
  serialize(): Uint8Array
  serialize(w: pb_1.BinaryWriter): void
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter()
    if (this.documentUpdates.length)
      writer.writeRepeatedMessage(1, this.documentUpdates, (item: DocumentUpdate) => item.serialize(writer))
    if (!w) return writer.getResultBuffer()
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DocumentUpdateArray {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new DocumentUpdateArray()
    while (reader.nextField()) {
      if (reader.isEndGroup()) break
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.documentUpdates, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, DocumentUpdate.deserialize(reader), DocumentUpdate),
          )
          break
        default:
          reader.skipField()
      }
    }
    return message
  }
  serializeBinary(): Uint8Array {
    return this.serialize()
  }
  static deserializeBinary(bytes: Uint8Array): DocumentUpdateArray {
    return DocumentUpdateArray.deserialize(bytes)
  }
}
