export type ItemMoveIndividualToShareRequest = {
  /* Encrypted ID of the source item to move */
  ItemID: string;
  /* Data to create the new item in the destination vault */
  Item?: ItemCreateRequest | null;
  /* Previous revisions of this item */
  History?: ItemHistoryRequest[];
  /* Item keys encrypted with the target vault key */
  ItemKeys: EncodedItemKeyRotation[];
};

export type ItemMoveSingleToShareRequest = {
  /* Encrypted ID of the destination share */
  ShareID: string;
  /* Data to create the new item */
  Item?: ItemCreateRequest | null;
  /* Previous revisions of this item */
  History?: ItemHistoryRequest[];
  /* Item keys encrypted with the target vault key */
  ItemKeys: EncodedItemKeyRotation[];
};

export type PublicLinkCreateRequest = {
  /* Last revision of the item */
  Revision: number;
  /* Expiration time for the link in seconds. Minimum 3600 (1h), at maximum 30 days in the future */
  ExpirationTime: number;
  /* Maximum amount of times that the item can be read. Unlimited reads if null */
  MaxReadCount?: number;
  /* Encrypted item key encoded in base64 */
  EncryptedItemKey: string;
  /* Link key encrypted with the share key encoded in base64 */
  EncryptedLinkKey: string;
  /* ShareKey rotation used for encrypting the encryptedLinkKey */
  LinkKeyShareKeyRotation: number;
  /* If the link key is being encrypted with the item key */
  LinkKeyEncryptedWithItemKey?: boolean;
};

export type PublicLinkGetContentResponse = {
  /* Base64 encoded item contents encrypted with the itemKey */
  Contents: string;
  /* Base64 encrypted item key */
  ItemKey: string;
  /* Token to use in order to fetch the files for the item. If null, the item does not have files */
  FilesToken?: string | null;
  /* ContentFormatVersion of the item contents */
  ContentFormatVersion: number;
  /* How many times the link has been read */
  ReadCount: number;
  /* If not null, the maximum amount of times the link can be read */
  MaxReadCount: number;
  /* Timestamp in seconds of the expiration time for the link */
  ExpirationTime: number;
  /* If the link key is being encrypted with the item key */
  LinkKeyEncryptedWithItemKey?: boolean;
};

export type PublicLinkGetResponse = {
  /* ID of the public link */
  LinkID: string;
  /* Number of times the item has been read */
  ReadCount: number;
  /* If not null, maximum number of times the item can be read */
  MaxReadCount: number;
  /* Link expiration timestamp */
  ExpirationTime: number;
  /* ShareID of the item that the link points at */
  ShareID: string;
  /* itemID of the item that the link points at */
  ItemID: string;
  /* URL to the link */
  LinkURL: string;
  /* LinkKey encrypted with the ShareKey in B64 */
  EncryptedLinkKey: string;
  /* KeyRotation for the ShareKey used to encrypt the LinkKey */
  LinkKeyShareKeyRotation: number;
  /* Whether the link is active or already expired/beyond read count */
  Active: boolean;
  /* If the link key is being encrypted with the item key */
  LinkKeyEncryptedWithItemKey?: boolean;
};
