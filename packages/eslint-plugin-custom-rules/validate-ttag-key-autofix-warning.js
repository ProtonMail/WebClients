const isJtCall = (node) => {
    return (
        node.type === 'TaggedTemplateExpression' &&
        node.tag &&
        node.tag.type === 'MemberExpression' &&
        node.tag.property &&
        node.tag.property.name === 'jt'
    );
};

const getKeyPropValue = (node) => {
    if (node.type === 'JSXElement') {
        const keyAttr = node.openingElement.attributes.find(
            (attr) => attr.type === 'JSXAttribute' && attr.name && attr.name.name === 'key'
        );
        if (keyAttr && keyAttr.value) {
            if (keyAttr.value.type === 'Literal') {
                return keyAttr.value.value;
            }
            if (keyAttr.value.type === 'JSXExpressionContainer' && keyAttr.value.expression) {
                if (keyAttr.value.expression.type === 'TemplateLiteral') {
                    // Handle template literals like key={`eslint-autofix-ABC123`}
                    const templateLiteral = keyAttr.value.expression;
                    if (templateLiteral.quasis.length === 1) {
                        // Single template literal without expressions
                        const rawValue = templateLiteral.quasis[0].value.raw;
                        if (rawValue.startsWith('eslint-autofix-')) {
                            return rawValue;
                        }
                    }
                }
            }
        }
    }
    return null;
};

const isAutoFixedKey = (keyValue) => {
    return keyValue === 'eslint-autofix' || (typeof keyValue === 'string' && keyValue.startsWith('eslint-autofix-'));
};

const findJsxElementForVariable = (variableName, context, node) => {
    const scope = context.sourceCode?.getScope?.(node) || context.getScope(node);
    const variable =
        scope.variables.find((v) => v.name === variableName) ||
        scope.upper?.variables.find((v) => v.name === variableName);

    if (variable && variable.defs.length > 0) {
        const def = variable.defs[0];
        if (def.node.type === 'VariableDeclarator' && def.node.init && def.node.init.type === 'JSXElement') {
            return def.node.init;
        }
    }
    return null;
};

const isReactElement = (node, context) => {
    // Direct JSX element
    if (node.type === 'JSXElement') {
        return true;
    }

    // Variable that might reference a JSX element
    if (node.type === 'Identifier') {
        // Find the variable declaration
        const scope = context.sourceCode?.getScope?.(node) || context.getScope(node);
        const variable =
            scope.variables.find((v) => v.name === node.name) ||
            scope.upper?.variables.find((v) => v.name === node.name);

        if (variable && variable.defs.length > 0) {
            const def = variable.defs[0];
            // Check if it's a variable declaration with JSX
            if (def.node.type === 'VariableDeclarator' && def.node.init) {
                return def.node.init.type === 'JSXElement';
            }
        }
    }

    return false;
};

const hasKeyProp = (node) => {
    if (node.type === 'JSXElement') {
        return node.openingElement.attributes.some(
            (attr) => attr.type === 'JSXAttribute' && attr.name && attr.name.name === 'key'
        );
    }
    return false;
};

/**
 * This function checks for auto-generated keys and warns about them.
 */
const checkForAutoGeneratedKeys = (node, context) => {
    if (!node.quasi || !node.quasi.expressions) {
        return;
    }

    node.quasi.expressions.forEach((expression) => {
        if (isReactElement(expression, context)) {
            // Direct JSX element
            if (expression.type === 'JSXElement') {
                if (hasKeyProp(expression)) {
                    // Has key - check if it's an auto-fixed key
                    const keyValue = getKeyPropValue(expression);
                    if (isAutoFixedKey(keyValue)) {
                        context.report({
                            node: expression,
                            message:
                                'Auto-generated key detected. Please replace with a meaningful key name for better maintainability.',
                        });
                    }
                }
            }
            // Variable reference to JSX element
            else if (expression.type === 'Identifier') {
                const jsxElement = findJsxElementForVariable(expression.name, context, expression);
                if (jsxElement && hasKeyProp(jsxElement)) {
                    // Has key - check if it's an auto-fixed key
                    const keyValue = getKeyPropValue(jsxElement);
                    if (isAutoFixedKey(keyValue)) {
                        context.report({
                            node: expression,
                            message: `Auto-generated key detected in variable '${expression.name}'. Please replace with a meaningful key name for better maintainability.`,
                        });
                    }
                }
            }
        }
    });
};

export default {
    meta: {
        docs: {
            description:
                'Warn about auto-generated key props in jt templates that should be replaced with meaningful names',
            category: 'Best Practices',
            recommended: true,
        },
    },
    create: (context) => {
        return {
            TaggedTemplateExpression(node) {
                // Check jt calls for auto-generated keys
                if (isJtCall(node)) {
                    checkForAutoGeneratedKeys(node, context);
                }
            },
        };
    },
};
